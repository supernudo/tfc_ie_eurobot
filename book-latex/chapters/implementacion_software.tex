%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Generic template for TFC/TFM/TFG/Tesis
%
% $Id$
%
% By:
%  + Javier Macías-Guarasa.
%    Departamento de Electrónica
%    Universidad de Alcalá
%  + Roberto Barra-Chicote.
%    Departamento de Ingeniería Electrónica
%    Universidad Politécnica de Madrid
%
% Based on original sources by Roberto Barra, Manuel Ocaña, Jesús Nuevo,
% Pedro Revenga, Fernando Herránz and Noelia Hernández. Thanks a lot to
% all of them, and to the many anonymous contributors found (thanks to
% google) that provided help in setting all this up.
%
% See also the additionalContributors.txt file to check the name of
% additional contributors to this work.
%
% If you think you can add pieces of relevant/useful examples,
% improvements, please contact us at (macias@depeca.uah.es)
%
% Copyleft 2013
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Desarrollo software}
\label{cha_implementacion_sofware}

\begin{FraseCelebre}
  \begin{Frase}
TODO
La imaginación es más importante que el conocimiento. El conocimiento es limitado y la imaginación circunda el mundo.    
  \end{Frase}
  \begin{Fuente}
Albert Einstein, en \emph{The Saturday Evening Post}
  \end{Fuente}
\end{FraseCelebre}


El desarrollo software del robot de Eurobot se organiza en capas o módulos funcionales, de forma que aquellos de nivel superior implementan funciones más abstractas que los inferiores. De mayor a menor nivel de abstracción, son las siguientes:

\begin{enumerate}
\item Estrategia de juego
\item Temática del juego
\item Sistemas mecánicos
\item Plataforma robótica base
\end{enumerate}

El módulo \emph{plataforma robótica} incluye las funcionalidades de desplazamiento, localización y evitación de obstáculos. Al mismo nivel, se encuentra el módulo \emph{sistemas mecánicos} encargado de controlar los mecanismos utilizados por el robot para manipular los elementos de juego. Ambos módulos se integran y se sincronizan en la capa de \emph{temática del juego} para implementar funcionalidades propias de la temática de Eurobot. Por último, la capa \emph{estratégia de juego} decide cuando y que acciones del juego realizar en cada momento para jugar un partido de Eurobot.

Así por ejemplo, si la capa de estrategia decide recolectar el tomate 1 llama a funciones del tipo \texttt{harvest\_tomato(TOMATO\_1)} de la capa de temática de juego, la cual a su vez utilizará funciones de la plataforma robótica del tipo \texttt{goto\_avoid\_xy(TOMATO\_1\_X, TOMATO\_1\_Y)} para moverse evitando los obstáculos hacia la posición del tomate 1 y, funciones de los sistemas mecánicos del tipo \texttt{system\_tomatoes\_set\_mode(MODE\_HARVEST)} para recolectar el tomate mediante el sistema mecánico de recolección de tomates.


\section{Librerias Aversive y Aversive4dspic}

La implementación SW de los robots se ha realizado a partir de las librerías Aversive \cite{aversive_src}, desarrolladas por el equipo de Eurobot Microb Technology \cite{microb}. Las librerías Aversive constituyen un marco de trabajo para el desarrollo de sistemas basados en microcontroladores AVR de Atmel. 

Las librerías Aversive4dspic son una migración de las librerías Aversive a microcontroladores dsPIC de Microchip, utilizados por en el HW desarrollado para los robots. Para realizar la migración de las librerías Aversive ha sido necesario desarrollar la capa de \emph{drivers de dispositivos HW} dependiente directamente del microcontrolador dsPIC, manteniendo las interfaces de los drivers equivalentes de microcontroladores AVR. Además ha sido necesario migrar dependencias específicas del compilador utilizado por las plataformas AVR al equivalente en el compilador para dsPICs. 

Las librerías Aversive4dspic mantienen la compatibilidad hacia atrás y permiten trabajar también con plataformas AVR. El código nuevo desarrollado o las modificaciones de código existente ha sido realizadas siguiendo la misma convención de código de las librerías originales.

Las librerías Aversive utilizan un \emph{toolchain} basado en la herramienta \texttt{make}. Así, a partir de un fichero \texttt{makefile} es posible configurar el proyecto para utilizar los módulos necesarios de la librería, especificar los ficheros de código fuente, compilar el código fuente y programar el microcontrolador. Además de soportar la compilación cruzada para microcontroladores AVR, estas librerías soportan la compilación y ejecución en \emph{HOST} para plataformas GNU/Linux.

Respecto las librerías Aversive4dspic, soportan la creación de un proyecto y configuración de los módulos a utilizar mediante la herramienta \texttt{make} y la compilación en \emph{HOST}. La compilación cruzada para microcontroladores dsPIC y su programación se realiza mediante el entorno de desarrollo de Microchip MPlab y MPlabX.

Las estructura de las librerías se divide en 5 carpetas principales:

\begin{itemize}
\item \textbf{\texttt{config}}: ficheros relacionados con la configuración de las librerías.

\item \textbf{\texttt{include}}: ficheros de cabecera generales, no relacionados con los módulos de la librería.

\item \textbf{\texttt{mk}}: ficheros \texttt{makefiles} de las librerias (proyecto, módulos y plantillas)

\item \textbf{\texttt{modules}}: módulos de la librería. Un módulo es una pequeña librería con una funcionalidad específica.

\item \textbf{\texttt{projects}}: ejemplos de proyecto.
\end{itemize}

Los módulos se encuentran organizados en las siguientes carpetas:

\begin{itemize}
\item \textbf{\texttt{modules/base}}: módulos comunes y frecuentemente utilizados.
\item \textbf{\texttt{modules/comm}}: módulos de comunicación (UART, SPI, I2C, ...).
\item \textbf{\texttt{modules/cryto}}: módulos para operaciones de cifrado de datos.
\item \textbf{\texttt{modules/debug}}: módulos de ayuda a la depuración.
\item \textbf{\texttt{modules/devices}}: módulos de dispositivos específicos no dependientes del HW del microcontrolador (LCDs, motores, ...).
\item \textbf{\texttt{modules/encoding}}: módulos de codificación (base 64, \emph{hamming}, ...).
\item \textbf{\texttt{modules/hardware}}: módulos de interfaces del microcontrolador (\emph{timers}, ADC, ...).
\item \textbf{\texttt{modules/ihm}}: módulos de interfaz hombre-maquina (menues, interfaz de comandos, ...)
\end{itemize}

Algunos módulos incluyen una configuración previa a la compilación. En estos casos, los módulos tienen asociado un fichero de cabecera de configuración con el formato \texttt{nombre\_modulo\_config.h}. Estos ficheros se encuentran en la carpeta \texttt{config} de cada módulo. Durante la configuración de un proyecto Aversive, estos ficheros son copiados a la carpeta raíz del proyecto, donde pueden ser modificados para ajustar la configuración a las necesidades del proyecto.

Por otro lado, cada uno de los módulos de la librerías incluye un proyecto de prueba. Este proyecto sirve para probar el correcto funcionamiento del módulo durante su desarrollo y como ejemplo de uso para aprender a utilizarlo. Los proyectos de prueba se encuentran en la carpeta \texttt{test} de cada módulo.

De cara a la implementación SW del robot de Eurobot (o cualquier sistema embebido), cada capa funcional utiliza ciertos módulos de la librería de funcionalidad muy específica. Sin embargo, hay algunos módulos que se utilizan transversalmente a todas las capas y que implementan funcionalidades comunes y útiles a todas ellas. Las siguientes secciones describen estas funcionalidades y los módulos utilizados en su implementación.

\subsection{Herramientas matemáticas}

La librería incluye varios módulos matemáticos que permiten realizar operaciones matemáticas en punto fijo o con objetos como polígonos y vectores:

\begin{itemize}
\item \textbf{\texttt{modules/base/math/fixed\_point}}: operaciones matemáticas en punto fijo.
\item \textbf{\texttt{modules/base/math/geometry}}: operaciones con puntos, lineas, polígonos y círculos.
\item \textbf{\texttt{modules/base/math/vect2}}: operaciones con vectores.
\end{itemize}

Estos módulos son utilizados por ejemplo para la implementación sistemas de control en punto fijo, o en la implementación de evitación de obstáculos del robot, donde cada obstáculo es representado por un polígono.

\subsection{Gestión de \emph{buffers} de datos}

Es muy común que para la implementación de interfaces de comunicación (UART, I2C, SPI, ...) se necesiten \emph{buffers} donde almacenar los datos que van a ser transmitidos o que se han recibido. Para ello puede utilizarse el módulo \textbf{\texttt{modules/comm/cirbuf}} que permite crear y gestionar buffers de datos circulares. 

\subsection{Planificador de eventos}

El módulo \textbf{\texttt{modules/base/scheduler}} implementa un planificador de eventos con prioridad. Los eventos pueden ser periódicos o eventuales, lo primeros llevan asociado un periodo y los segundos un instante de ejecución a partir del momento de creación.

El módulo \emph{scheduler} está pensado para ejecutarse en la interrupción de un \emph{timer}, el periodo de dicho \emph{timer} constituye el periodo base del \emph{scheduler} (por ejemplo 1ms). Cada periodo se evalúa que evento ejecutar. Dado que los eventos se ejecutan en un contexto de interrupción las funciones asociadas a estos han de ser de corta duración y no bloqueantes.

Mediante eventos del \emph{scheduler} el robot implementa por ejemplo la lectura de sensores cada 10ms, los sistemas de control cada 5ms o los protocolos de comunicación con la baliza o el robot secundario cada 10ms.  

\subsection{Medida de tiempo}

El módulo \textbf{\texttt{modules/base/time}} permite medir de tiempo del sistema. Este módulo se ejecuta como un evento del \emph{scheduler} y su periodo de ejecución se corresponde con la resolución de medida del tiempo. Permite obtener el tiempo transcurrido desde su inicialización en horas, minutos, segundos y microsegundos. 

Este módulo permite implementar esperas bloqueantes o no bloqueantes. Por ejemplo, a los 90 segundos los robots han de dejar de jugar y desactivar todos los sistemas. Esta espera se puede implementar de forma precisa a partir de este módulo evaluando periódicamente el número de segundos transcurridos desde el inicio de partido.  

\subsection{Mensajes de depuración}

El módulo \textbf{\texttt{modules/debug/error}} implementa mensajes de depuración o \emph{logs} que permiten trazar el funcionamiento del software implementado con el fin de verificar su correcta ejecución. Cada mensaje tiene asociado un número de error y un nivel de gravedad: EMERG, ERROR, WARNING, NOTICE y DEBUG. 

El módulo permite definir la función a partir de cual los mensajes son generados para cada nivel de gravedad. En dicha función se define el formato de los mensajes, la información de estos y la interfaz por la cual son transmitidos (UART, SPI, I2C, etc.). 

El software desarrollado para los robots y los módulos de las librerías utilizan el módulo \emph{error}. En este caso, la función que genera los mensajes utiliza la salida estándar (conectada a una UART) para transmitir los mensajes. Esta función, además, filtra los mensajes por número de error y nivel de gravedad, de forma que sólo aquellos mensajes con números de error habilitados y de nivel de gravedad superior al establecido serán transmitidos, con la excepción de los mensajes de nivel ERROR que serán siempre transmitidos.


\subsection{Interfaz de linea comandos}

Las librerías permiten implementar una interfaz de linea comandos similar a la de sistemas GNU/Linux con las siguientes características:

\begin{itemize}
\item Interfaz de comunicación serie configurable (UART, I2C, SPI, ...).
\item Caracteres imprimibles y no imprimibles VT100.
\item Ayuda/información de cada comando.
\item Completado automático de argumentos y sugerencia del tipo de argumento a introducir.
\item Tipo de argumentos: texto (\emph{strings}), números enteros (8 y 16 bits) y números decimales (\emph{float}). 
\item Comprobación de número argumentos y tipo de los argumentos.
\item Histórico de comandos ejecutados
\end{itemize}

La interfaz de linea de comandos se implementa a partir de los siguientes módulos:

\begin{itemize}
\item \textbf{\texttt{modules/ihm/vt100}}: módulo que permite interpretar los caracteres no imprimibles VT100.
\item \textbf{\texttt{modules/ihm/rdline}}: módulo de lectura de una linea, terminada en retorno de carro, a través de una interfaz serie de entrada, por ejemplo una UART.
\item \textbf{\texttt{modules/ihm/parse}}: módulo que realiza la correlación de una linea con los posibles comandos a ejecutar y sus argumentes, y en caso de coincidencia, ejecuta el comando correspondiente.
\end{itemize}

Los módulos \texttt{rdline} y \texttt{parse} utilizan el módulo \texttt{vt100} para poder interpretar los caracteres no imprimibles como el tabulador o los cursores. Por ejemplo, el tabulador es utilizado para completar un argumento tipo texto o para indicar el tipo del argumento siguiente. Por otro lado, los cursores permiten moverse por el listado de comandos ejecutados o por una linea escrita para modificarla.

El módulo \emph{parse} tiene asociado una lista de comandos y cada comando tiene asociado unos parámetros de entrada y una función a ejecutar. A medida que \emph{rdline} recibe una linea utiliza información del la lista de comandos de \emph{parse} para implementar el completado de argumentos de texto o indicar el tipo del siguiente argumento. Si el comando y sus argumentos coinciden con alguno de los comandos de la lista de comandos, el módulo \emph{parse} ejecuta la función asociada al comando, propagando los argumentos introducidos por la línea de comandos a dicha función.

En el caso del desarrollo software del robot de Eurobot, la interfaz de linea de comandos constituye la capa de mayor nivel, más abstracta y la interfaz entre el robot y sus desarrolladores. La linea de comandos está presente durante todo el desarrollo del robot e implementa comandos mediante los cuales controlar o probar el funcionamiento de las diferentes capas o niveles del software. Así, hay comandos que permiten controlar directamente el HW del robot, como la generación de señales PWM o la lectura del valor de sensores, o comandos muchos más abstractos que permiten mover el robot hasta una posición (x,y) del campo o iniciar un partido de Eurobot.

 
\section{Arquitectura software}

La arquitectura SW desarrollada se definió en el año 2010 durante el desarrollo del robot Tropetero. Por aquel entonces sólo se competía con un robot por equipo, más tarde, en el año 2014 la arquitectura evolucionó hacia la competición con dos robots por equipo. 

La figura \ref{fig_sw_diagrama_bloques} muestra el diagrama de bloques SW de un equipo de dos robots: un robot principal y uno secundario. Ambos robots implementan la misma arquitectura SW diferenciándose únicamente en el número de elementos implicados en la implementación. Debido a la complejidad de los sistemas mecánicos del robot principal, éste implementa la arquitectura mediante dos microcontroladores, mientras que el robot secundario utiliza un único microcontrolador. Además, la baliza tipo faro del robot principal constituye un sistema independiente, mientras que la baliza del robot secundario se encuentra integrada en la arquitectura HW y SW del robot. 

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{sw_diagrama_bloques}
\caption[]{Diagrama de bloques software del robot principal y secundario}
\label{fig_sw_diagrama_bloques}
\end{figure}

Cada robot tiene una interfaz serie que permite acceder a la linea de comandos de cada uno utilizando un terminal serie de un ordenador. En el caso del robot principal, utiliza una interfaz serie RS-232, mientras que el robot secundario utiliza una interfaz serie Bluetooth (perfil SPP, \emph{Serial Port Profile}).

Ambos robots y la baliza del robot principal se encuentran conectados mediante sendos canales serie Bluetooth. Estos canales son utilizados para implementar el protocolo de comunicación entre el robot principal y la baliza, y entre el robot principal y el robot secundario. También es posible utilizar estos canales Bluetooth para acceder a la linea de comandos de la baliza y del robot secundario desde el terminal serie del ordenador, a partir de un \emph{bypass} de los datos en el robot principal.

Igualmente, ambos robots utilizan una interfaz I2C maestro-esclavo para acceder a dispositivos de expansión de E/S, a los que se encuentran conectados sensores. Además, en el caso del robot principal, esta interfaz es utilizada por el microcontrolador principal para comunicarse con el microcontrolador esclavo (SLAVE DSPIC), el cual implementa el control de sistemas mecánicos. Mediante la interfaz I2C se implementa un protocolo de mensajes que permite compartir la información de los dispositivos conectados al bus (sensores) con ambos microcontroladores y, una gestión de los sistemas mecánicos por parte del microcontrolador principal. 

Por otro lado, como se puede observar en la figura \ref{fig_sw_diagrama_bloques}, la arquitectura SW de cada robot se organiza en las siguientes capas y módulos funcionales:

\begin{description}
\item \textbf{Drivers de dispositivos HW}

Esta capa permite abstraer los módulos o dispositivos HW del robot, como módulos de comunicación del microcontrolador (UART, I2C, SPI, ...) o dispositivos externos a éste como servomotores, o drivers en puente en H para el control de motores. Éste nivel  trabaja, por ejemplo, con funciones del tipo \texttt{uart\_send(UART0, dato)} para transmitir un dato por la UART numero 0, o \texttt{pwm\_mc\_set(OUT1,-1000} para fijar el valor y sentido del motor conectado al la salida OUT1 a -1000. 

\item \textbf{Plataforma robótica base}

Módulo que implementa las funcionalidades de la plataforma robótica base: control de posición, odometría, gestión de trayectorias y evitación de obstáculos. Implementa funciones del tipo \texttt{robot\_goto\_xy(1000, 500)} para ir al punto (x=1000, y=500), o  \texttt{robot\_get\_xy()} para obtener la coordenada (x,y) del robot.

\item \textbf{Sistemas mecánicos}

Módulo que abstrae el control de los diferentes sistemas mecánicos del robot mediante los cuales se manipulan los elementos del  juego. Éste módulo trabaja con funciones del estilo \texttt{system\_tomatoes\_set\_mode(HARVEST)} (configura el sistema de tomates en modo recolección), o  como \texttt{system\_tomatoes\_get\_num()} (obtener el número de tomates recolectados).

\item \textbf{Temática del juego}

Esta capa permite abstraer completamente las funcionalidades de la plataforma robótica y de los sistemas mecánicos e integra la información de la baliza. De esta forma, a este nivel se trabaja con funciones que sincronizan los movimientos del robot con los sistemas mecánicos, como \texttt{harvest\_tomato(TOMATO\_1)} (ir hasta la posición del tomate 1 y recolectarlo).

Esta capa también tiene funciones que integran la información de varios módulos, como la información de odometría, del tiempo transcurrido, de la baliza y de los sensores de obstáculos. Es el caso de la función \texttt{wait\_traj\_end(END\_TRAJ|END\_TIMER|END\_OBSTACLE)} que esperar el fin de una trayectoria debido a diferentes razones: \emph{punto destino alcanzado}, \emph{tiempo de partido se acaba}, o por \emph{obstáculo en el camino encontrado}.


\item \textbf{Estrategia de juego}

Esta capa implementa la estrategia de juego de un partido así como las diferentes fases de las que se compone un partido. Las funciones esperadas a este nivel son del tipo \texttt{is\_the\_opponent\_in\_zone(ZONE\_TOMATOES\_1)} (¿está el oponente en la zona de los tomates?), o \texttt{goto\_zone(ZONE\_TOMATOES\_1)} (ir a la zona de los tomates), o \texttt{work\_on\_zone(ZONE\_TOMATOES\_1)} (trabajar en la zona de los tomates).

Como se puede observar en la \ref{fig_sw_diagrama_bloques}, la capa \emph{estrategia de juego} no se encuentra implementada en el robot secundario. Esto es debido a que la estrategia se encuentra centralizada en el robot principal y, es éste, el que decide en todo momento lo que le corresponde hacer al robot secundario. 

\item \textbf{Linea de comandos}

La linea de comandos permite ejecutar comandos de cualquier módulo o nivel. De esta forma durante el desarrollo de las diferentes capas o módulos, las funcionalidades de éstas pueden ser probadas por partes y verificar su correcto funcionamiento. Por ejemplo a nivel estrategia el comando \texttt{init yellow}, inicializa los robots para jugar en el lado amarillo del campo de juego. Y mediante el comando \texttt{start qualification match}, se ejecuta un partido con la estrategia diseñada para la fase de clasificación de una competición de Eurobot.

\end{description}

Respecto al módulo \emph{sistemas mecánicos} a su vez se encuentra dividido en varias capas o módulos, los cuales se encuentran representados en el microcontrolador esclavo del robot principal, el cual, implementa únicamente el control de los sistemas mecánicos (ver figura \ref{fig_sw_diagrama_bloques}). Aclarar, que en el caso del robot secundario estas capas se encuentra integradas en un único microcontrolador. 



\section{Implementación funcional}
A continuación se describe la implementación funcional de los módulos y capas principales de la arquitectura SW del robot de Eurobot. El orden seguido es el mismo en el que se suelen desarrollar, de menor a mayor nivel de abstracción.


\subsection{Plataforma robótica base}

Como se ha visto en la sección de arquitectura SW, la plataforma robótica base se sitúa entre la capa \emph{Drivers de dispositivos HW} y la capa \emph{Temática del juego}. Este módulo implementa los siguientes bloques funcionalidades del robot:

\begin{itemize}
\item Gestión de trayectorias
\item Control de posición
\item Posicionamiento por odometría
\item Detección de bloqueos
\end{itemize}

La figura \ref{fig_sw_diagrama_plataforma_robotica} representa el diagrama de bloques funcional de cada uno de estos bloques y su relación con otros módulos o capas de la arquitectura SW. Su implementación se ha realizado utilizando las librerías Aversive4dspic. Principalmente a partir de módulos de implementación de sistemas de control (\texttt{modules/devices/control\_system}) y módulos específicos de implementación de plataformas robóticas (\texttt{modules/devices/robot}). Todos ellos se ejecutan periódicamente como eventos del módulo \texttt{scheduler}.


\subsubsection{Gestión de trayectorias}

La gestión de trayectorias está compuesta por los módulos siguientes:

\begin{description}
\item \texttt{modules/devices/robot/}\textbf{\texttt{trajectory\_manager}}

Módulo de gestión de trayectorias que calcula la trayectoria para alcanzar un punto destino, a partir de las coordenadas de dicho punto y de la posición actual del robot. El estado de la ejecución de la trayectoria puede consultarse en todo momento. Dicho estado informa de si la trayectoria está en proceso o si ha finalizado satisfactoriamente. 

Para alcanzar las coordenadas de destino, pueden ser necesarios varios movimientos del robot (lineales o de orientación). Estos movimientos se corresponden a consignas de posición de distancia y ángulo. Las consignas generadas por el módulo de gestión de trayectorias son procesadas por el control de posición.

\item \texttt{modules/devices/robot/}\textbf{\texttt{obstacle\_avoidance}}

Módulo de evitación de obstáculos que permite a partir de un punto de destino y una lista de obstáculos, representados por polígonos, obtener el camino más corto para llegar a dicho punto. Como resultado, el módulo devuelve la lista de puntos que representa el camino a seguir.
\end{description}

Estos dos módulo permiten por ejemplo, implementar a nivel de temática del juego una función que permita al robot ir hasta un punto determinado del campo de juego, independientemente de si hay obstáculos en medio. El nivel de temática de juego conoce las dimensiones del campo de juego, la posición de sus elementos, y tiene información de la posición de los oponentes (obtenida de la baliza). Así por ejemplo, la función \texttt{goto\_avoid(x,y)} de la figura \ref{fig_sw_diagrama_plataforma_robotica} utiliza el módulo de evitación de obstáculos para obtener los puntos del camino a recorrer para alcanzar una coordenada (x,y), y mediante el módulo de gestión de trayectorias hace que el robot vaya pasando por cada uno de ellos hasta llegar al destino.

\begin{figure}[p]
\centering
\includegraphics[width=.9\textwidth]{sw_diagrama_plataforma_robotica}
\caption[]{Diagrama de organización y funcionamiento SW de la plataforma robótica base}
\label{fig_sw_diagrama_plataforma_robotica}
\end{figure}

\subsubsection{Control de posición}

El control de posición se implementa a partir de dos módulos principalmente:

\begin{description}
\item \texttt{modules/devices/robot/}\textbf{\texttt{robot\_system}}

Módulo que hace de interfaz entre los drivers de dispositivos HW, y el control de posición y odometría. Por un lado, convierte los pulsos de los encoders, a medidas de posición y ángulo del robot. Y por otro, convierte las señales de control de distancia y ángulo, a valores de PWM para cada motor.

\item \texttt{modules/devices/control\_system/}\textbf{\texttt{control\_system\_manager}}

Modulo a partir del cual se implementan los controladores de posición de distancia y ángulo del  robot. El módulo gestiona y hace de interfaz entre los diferentes bloques que forma un sistemas de control clásico.

\end{description}

El control de posición polar del robot se implementa de la siguiente forma. Por un lado, el módulo de gestión de sistemas de control recoge las consignas de posición dadas por el gestor de trayectorias. Éstas consignas de posición son filtradas por un módulo \texttt{quadramp} (\texttt{modules/devices/control\_system/filters}) para implementar un perfil de velocidad trapezoidal. A partir de la posición en distancia y ángulo del robot, dada por el módulo \texttt{robot\_system}, y las consignas filtradas, se calculan los errores de posición en ángulo y distancia. Dichos errores, son procesados por un filtro \texttt{pid} que calcula la señal de control de cada controlador. Por último, estas señales de control, son traducidas por el módulo \texttt{robot\_system} a valores de señal PWM y aplicadas a los motores por medio del driver de motores. 



\subsubsection{Odometría}

La odometría se implementa a partir del módulo \textbf{\texttt{position\_manager}}, pertenece al grupo de módulos de implementación de robots (\texttt{modules/devices/robot/}). Este módulo recibe la medida de posición en distancia y ángulo del módulo \texttt{robot\_system} y calcula la posición del robot a partir de algoritmos de odometría. La posición del robot es utilizada por el módulo de gestión de trayectorias, pero además, podría ser utilizada por capas SW de mayor nivel.


\subsubsection{Detección de bloqueos}

La detección de bloqueos se implementa a partir del módulo \textbf{\texttt{blocking\_detection\_manager}}, al igual que el módulo de odometría, también pertenece al grupo de módulos de implementación de robots (\texttt{modules/devices/robot/}). Este módulo estima la corriente de los motores de tracción a partir de la medida de velocidad de los encoders y de la señal de control de distancia y ángulo de los motores. En caso de que la corriente estimada supere un umbral máximo durante un tiempo determinado, la detección es notificada, de forma que la trayectoria en curso se pueda abortar.

Observar que la función \texttt{goto\_avoid(x,y)}, descrita anteriormente, además de comprobar el estado de la trayectoria en ejecución, puede comprobar si durante la misma se detecta un bloqueo mecánico, e interrumpir la ejecución si lo considera oportuno.



\subsection{Sistemas mecánicos}

Los sistemas mecánicos se encuentra al mismo nivel que la plataforma robótica base, por lo tanto se sitúa igualmente entre la capa \emph{Drivers de dispositivos HW} y la capa \emph{Temática del juego}.

El módulo de sistemas mecánicos tiene como objetivo abstraer su control y gestión a capas superiores, como la temática de juego o la estrategia. La implementación SW se divide en varias capas y módulos: 

\begin{description}
\item \textbf{Sensores}

Módulo encargado de la adquisición y procesamiento de los sensores de los sistemas mecánicos (finales de carrera, medidores de distancia, detectores de color, etc.). Este módulo implementa funciones del tipo \texttt{sensor\_get(SENSOR1)} para, por ejemplo, leer el estado del sensor numero 1.

\item \textbf{Actuadores}

Módulo de control de los actuadores de los mecanismos (servomotores, motores, electroválvulas, etc). Este módulo implementa funciones del tipo \texttt{ax12\_set\_pos(AX12\_ID\_1, 512)} (mover el servomotor AX12 a la posición 512).

\item \textbf{Control de mecanismos}

Esta capa abstrae e integra los actuadores y sensores que forman mecanismos funcionales. Por ejemplo, un mecanismo puede ser un brazo robótico formado por varios servomotores y una pinza, o un clasificador de tomates compuesto por un palo movido por un servomotor. De esta forma se utilizan funciones del tipo \texttt{arm\_goto\_xy()} para llevar al brazo a una coordenada, o funciones como \texttt{tomatoes\_clasiffier\_set\_pos(SIDE\_LEFT)} para clasificar un tomate hacia el lado izquierdo.

\item \textbf{Control de sistemas mecánicos}

Esta capa gestiona los diferentes mecanismos de los que se compone un sistema mecánico, e implementa los diferentes modos de funcionamiento de éste. Por ejemplo, un sistema mecánico puede ser el sistema de recolección de tomates. Éste sistema puede estar compuesto por un mecanismo de clasificación de tomates, un sensor detector de presencia de tomates, un mecanismo de almacenamiento y un mecanismo de liberación de los tomates recolectados. El sistema, por ejemplo, puede trabajar en modo \emph{recolectar} o \emph{liberar tomates} y, permite \emph{clasificar} los tomates rojos y verdes. Dependiendo del modo de funcionamiento se han de utilizar unos mecanismos u otros.

La forma más común de implementar esta capa es mediante máquinas de estado. Por ejemplo, la maquina de estados del ejemplo anterior puede corresponderse con la función \texttt{do\_sytem\_tomatoes(uint8\_t mode, uint8\_t tomato\_type)}, la cual permite hacer funcionar el sistema de recolección de tomates en sus diferente modos de funcionamiento (parámetro \texttt(mode)), y elegir el tipo de tomate (parámetro \texttt{tomato\_type}).  

\end{description}

Por ejemplo, en el juego \emph{Robomovies} de Eurobot 2015, los robots tenían que realizar las siguiente acciones:

\begin{itemize}
\item Construir focos de cine (\emph{spotlights}) a partir de las piezas (\emph{stands} y \emph{bulblight}) repartidas por todo el campo de juego. 
\item Cerrar unas claquetas de cine (\emph{claperboards}).
\item Llenar vasos con palomitas de maíz (\emph{popcorns}).
\item Poner unas alfombras rojas es una escalinata.
\item Subir la escalinata.
\end{itemize} 

Entre todas estas acciones el robot P.Tinto se encargaba de las tres primeras. Para cada una de ellas, P.Tinto tenía un sistema mecánico dedicado. De forma que a cada sistema mecánico le corresponde una implementación HW y SW.

La figura \ref{fig_sw_diagrama_sys_mecanicos} representa la organización y funcionamiento de la implementación SW de los sistemas mecánicos de P.Tinto:

\begin{itemize}
\item Sistema de focos de cine (\texttt{stands\_system})
\item Sistema de palomitas (\texttt{popcorns\_system})
\item Sistema de claquetas (\texttt{claperboards\_system}) 
\end{itemize}

Los módulos correspondientes a estos sistemas forman el nivel de \emph{control de sistemas mecánicos}. Por encima, el nivel de \emph{temática de juego} gestiona los modos de funcionamiento de éstos y obtiene información de su estado.

En la figura \ref{fig_sw_diagrama_sys_mecanicos} se representa concretamente el funcionamiento del sistema de focos de cine (\texttt{stands\_system}). Este sistema maneja las piezas (\emph{stands}) con las que se construyen los focos de cine. Permite apilar los \emph{stands} en dos torres de hasta 4 elementos, y posteriormente construir un foco de cine de hasta 8 elementos mediante un mecanismo que transporta los \emph{stands} de una torre a otra.

El sistema de \emph{stands} se compone de varios mecanismos. Cada uno de ellos tiene asociado un módulo SW controlador: 

\begin{itemize}
\item 2 elevadores de \emph{stands} (\texttt{stand\_elevator})
\item 2 pinzas de sujeción de torres de \emph{stands}  (\texttt{})
\item 2 clasificadores de \emph{stands}  (\texttt{stand\_blades})
\item 1 intercambiador de \emph{stands}  (\texttt{stand\_exchanger})
\item 2 pinzas de \emph{stands}  (\texttt{stands\_claps})
\end{itemize} 

Los controladores de mecanismos hacen de interfaz entre la funcionalidad del mecanismo y los actuadores con los que está construidos. Un ejemplo sencillo es la pinza que coge los \emph{stands}, esta tiene dos consignas posibles: abierta o cerrada; y a cada una le corresponde una consigna de posición de un servomotor. Un ejemplo más complejo sería el de un brazo robótico, formado por varios servomotores, cuya consigna sea una posición del espacio (x,y,z). En este caso, para alcanzar dicha consigna es necesario realizar el control sincronizado de todos los servomotores.

Por debajo del nivel de \emph{control de mecanismos} se encuentra la \emph{lectura y procesamiento de sensores} y el \emph{control de actuadores}. Los sistemas mecánicos utilizan sensores para sincronizar los movimientos de los mecanismos. En el caso de P.Tinto, un sensor a la entrada del sistema de focos de cine permite detectar cuando un \emph{stand} se encuentra en la entrada y puede ser recolectado.

En el caso de la figura \ref{fig_sw_diagrama_sys_mecanicos} los mecanismos están formados por los siguientes tipos de actuadores, y sus módulos controladores SW correspondientes:

\begin{itemize}
\item Motores (\texttt{cs})
\item Servomotores AX12 (\texttt{ax12\_manager})
\item Servomotores estándar
\end{itemize} 

El módulo \texttt{cs} implementa un sistema de control utilizando las librerías Aversive4dspic, de igual forma que la plataforma robótica implementa el control de posición del robot. Tanto el controlador de motores como el de servomotores AX12 permiten conocer la posición real del actuador. Esta información es utilizado para sincronizar las operaciones sin necesitar de sensores adicionales. Sin embargo, en el caso de los servomotores estándar no es posible obtener directamente esta información, y la sincronización ha de realizarse por tiempo o mediante sensores adicionales. Notar que en el caso del mecanismo \texttt{stands\_clamps} no existe controlador de actuadores, y utiliza directamente el driver generador de PWM \texttt{pwm\_servo}.


\begin{figure}[p]
\centering
\includegraphics[width=\textwidth]{sw_diagrama_sys_mecanicos}
\caption[]{Diagrama de organización y funcionamiento SW de los sistemas mecánicos}
\label{fig_sw_diagrama_sys_mecanicos}
\end{figure}

\subsection{Temática de juego}

El nivel de \emph{temática de juego} integra toda la funcionalidad de los niveles inferiores y sistemas externos, como la baliza y el robot secundario, para implementar las funcionalidades del robot relativas a la prueba de Eurobot y a la navegación del robot por el campo de juego. En el supuesto de que el robot de Eurobot fuese un producto comercial (un juguete) el desarrollo del mismo llegaría hasta este nivel. A partir de aquí, el usuario del robot podría programar el nivel de estrategia para competir con otros robots en un partido de Eurobot.

Por otro lado, el nivel de \emph{estrategia} básicamente utiliza los recursos que le brinda la \emph{temática de juego} para así realizar las acciones del juego en un orden determinado. 

La figura \ref{fig_sw_estrategia_y_tematica} representa la funcionalidad y organización de estos dos niveles de implementación SW, así como la relación entre los módulos que los componen.

La implementación de la \textbf{temática de juego} se divide principalmente en dos tipos de módulos:

\begin{itemize}
\item Módulos de navegación del robot
\item Módulos de acciones del juego
\item Módulos de ayuda a la estrategia
\end{itemize} 

Los módulos de navegación son los siguientes:

\begin{description}
\item \textbf{\texttt{strat\_base}}

Módulo principal de navegación. Permite iniciar una trayectoria hacia un punto dado y conocer el fin de la misma. Para ejecutar la trayectoria utiliza el módulo de gestión de trayectorias del la plataforma robótica. El final de una trayectoria se determina a partir de la información de varios módulos:

\begin{itemize}
\item Punto destino alcanzado: obtenido por el módulo de gestión de trayectorias.
\item Punto destino cercano: el robot se encuentra cerca del punto destino (a una distancia máxima). Esta información es dada también por el módulo de gestión de trayectorias.
\item Obstáculo en la trayectoria: por detección de los sensores de obstáculos de corto alcance.
\item Oponente en la trayectoria: por la información de la baliza.
\item Tiempo de partido: por la cuenta de tiempo de partido (módulo Aversive4dspic \texttt{time}.
\end{itemize}

Además, este módulo implementa la gestión de la velocidad durante las trayectoria dependiendo de la posición y distancia a los oponentes. Por ejemplo, al acercarse o pasar por el lado de un oponente la velocidad se decrementa para prevenir una posible colisión o maniobra de evitación. 

\item \textbf{\texttt{strat\_avoid}}

Módulo que implementa la navegación con obstáculos. Para ello utiliza el módulo de evitación de obstáculos de la plataforma robótica. A partir de la posición de los elementos del campo de juego y de los oponentes, obtiene la lista de puntos que define el camino a seguir para alcanzar el destino. Cada tramo del camino es ejecutado como una trayectoria por la plataforma robótica. 

El fin de cada tramo se obtiene del modulo \texttt{strat\_base}. La utilización de la condición de \emph{punto cercano} para los tramos intermedios permite realizar caminos más suaves, ya que el robot no llega a pararse, enlazando los puntos como una única trayectoria.

\end{description} 


Respecto a los módulos relativos a acciones del juego, estos tienen una fuerte dependencia con el mismo. Continuando con el ejemplo de los sistemas mecánicos, la figura \ref{fig_sw_estrategia_y_tematica} muestra los correspondientes al robot P.Tinto:

\begin{itemize}
\item \textbf{\texttt{strat\_clapperboard}}: acciones de claquetas de cine.
\item \textbf{\texttt{strat\_popcorn}}: acciones de vas de palomitas.
\item \textbf{\texttt{strat\_spotlight}}: acciones de focos de cine.
\item \textbf{\texttt{strat\_secondary\_robot}}: acciones delegadas en el robot secundario. Incluyen acciones de claquetas, vasos de palomitas y de las alfombras rojas.
\end{itemize}

Los módulos funcionan siguiendo un mismo patrón que implementa la sincronización de movimientos del robot con la manipulación de elementos de juego. La figura \ref{fig_sw_estrategia_y_tematica} muestra el caso del modulo \texttt{strat\_spotlight}. Por un lado, las acciones a realizar están pensadas para ser ejecutadas en las cercanías de los elementos de juego donde los desplazamientos son pequeños. Por ello, se realizan trayectorias sin evitación de obstáculos utilizando el módulos. Por otro lado, la manipulación de los elementos se realiza a partir de los modos de funcionamiento del sistema mecánico correspondiente. La sincronización se consigue a partir del estado de la trayectoria y de los mecanismos.

La forma de llegar hasta el control de los sistemas mecánicos depende de donde estén implementados. En el caso del módulo \texttt{strat\_spotlight} se realiza por medio del protocolo I2C, ya que los sistemas mecánicos se encuentra implementados en el microcontrolador esclavo. Igualmente, las acciones delegadas en el robot secundario, gestionadas por medio del enlace Bluetooth y del protocolo de comunicaciones asociado.


Por último, el módulo \textbf{\texttt{strat\_utils}} implementa funciones de ayuda a la estrategia a partir de información posición del robot, obtenida de la odometría de la plataforma base, e información de la posición de los oponentes.


\begin{figure}[p]
\centering
\includegraphics[width=\textwidth]{sw_diagrama_estrategia_y_tematica}
\caption[]{Diagrama de organización y funcionamiento SW de los niveles de estrategia y temática del juego}
\label{fig_sw_estrategia_y_tematica}
\end{figure}


\subsection{Estrategia de juego}

Los robots desarrollados han implementado alguna de estas estrategias o combinación de ellas:

\begin{description}
\item \textbf{Estrategia secuencial bloqueante}

Estrategia en la que el robot sigue una secuencia de movimientos y acciones. En caso de encontrar un obstáculo espera hasta que éste desaparezca para continuar.

\item \textbf{Estrategia reactiva}

Estrategia en la que el robot reacciona ante los obstáculos, evitándolos o realizando acciones alternativas. Además, decide que acciones realizar en función de la posición actual del oponente y zonas que el oponente ha visitado. 

\item \textbf{Estrategia basada en prioridades}

Estrategia que decide las acciones a realizar basándose en la prioridad de las mismas. En caso de no poder realizar la acción más prioritaria, salta a la siguiente en prioridad.

\item \textbf{Estrategia adaptativa}

Estrategia que en función de la evolución del partido, a partir de las acciones realizadas por el oponente y el tiempo, cambia dinámicamente las prioridades de las acciones.

\item \textbf{Estrategia sincronizada}

Estrategia en la que las acciones se realizan de forma sincronizada entre dos robots.

\end{description}


La implementación de las estrategias se ha realizado utilizando un patrón basado en zonas de trabajo y prioridades. En este patrón el campo se divide en zonas de trabajo. Cada de ellas tiene asociado varios elementos:

\begin{itemize}
\item Tipo de elemento de juego: en el caso del robot P.Tinto, claquetas, \emph{stands} o palomitas.
\item Área de trabajo: área necesaria para trabajar en la zona.
\item Posición de inicio: posición inicial desde la que se trabaja en la zona.
\item Posición del elemento: posición del elemento de juego a manipular.
\item Prioridad: prioridad de la zona de trabajo.
\item \emph{Flags} de control: señales de control para la gestión de estrategia. Por ejemplo, para marcar si la zona ya ha sido trabajada o si ha sido visitada por el oponente.
\item Robot: robot que puede trabajar en la zona, que tiene la funcionalidad.
\end{itemize}

Una vez definidas todas las zonas, la estrategia interpreta la información de cada zona para decidir a que zona ir a trabajar. El algoritmo a seguir consta de 3 fases que se repiten continuamente:

\begin{enumerate}
\item Obtener la zona de mayor prioridad y válida
\item Ir a la zona
\item Trabajar en la zona
\end{enumerate}

Este patrón se encuentra representado en el bloque de estrategia de juego del la figura \ref{fig_sw_estrategia_y_tematica}. La estrategia al comienzo de partido, o de forma dinámica durante el partido, configura las prioridades de cada zona mediante el módulo \texttt{strat\_strategies}. 

La obtención de la siguiente zona a la que ir a trabajar, se realiza a partir de la información de este módulo y en base a los criterios de zona válida establecidos. Por ejemplo, un criterio fundamental es que el oponente no se encuentre trabajando en la zona. Esta comprobación se realiza mediante el módulo \texttt{strat\_utils} de la temática de juego.

El desplazamiento a la zona elegida se realiza utilizando el modulo \texttt{strat\_avoid}, que permite evitar los posibles obstáculos en el camino hacia el punto de inicio de la zona. Si la zona no pudiese ser alcanzada se volvería a obtener una nueva zona.

Una vez alcanzada la zona, en función del tipo de elemento de juego se utilizaría el módulo de la temática correspondiente. Por ejemplo, si la zona es tipo \emph{stand} se llamaría a la función de recolección de \emph{stands} del módulo \texttt{strat\_spotlight}.



\section{Simulador de robots}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{sw_diagrama_bloques_simulador}
\caption[]{Diagrama de bloques software del simulador de robots y campo de juego}
\end{figure}


%%% Local Variables:
%%% TeX-master: "../book"
%%% End:
